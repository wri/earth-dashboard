define(["./when-208fe5b0","./Cartesian2-8417ca3d","./arrayRemoveDuplicates-0f62a181","./BoundingRectangle-7ee12c46","./Transforms-a73b3b3b","./ComponentDatatype-9204e9f6","./PolylineVolumeGeometryLibrary-66348bfe","./Check-d18af7c4","./GeometryAttribute-04a19cfe","./GeometryAttributes-b0b294d8","./GeometryPipeline-5e672526","./IndexDatatype-d47ad6f6","./Math-4e53b694","./PolygonPipeline-4d0ff0fe","./VertexFormat-e8cbf5b3","./RuntimeError-7f634f5d","./WebGLConstants-76bb35d1","./EllipsoidTangentPlane-9123a53b","./IntersectionTests-7d224a2f","./Plane-4aa8974d","./PolylinePipeline-28f5feec","./EllipsoidGeodesic-8015072b","./EllipsoidRhumbLine-28521929","./AttributeCompression-f02ec82f","./EncodedCartesian3-874933de"],(function(e,t,n,i,r,a,o,l,s,p,d,u,c,g,y,m,h,f,b,v,E,P,_,x,k){"use strict";var C={};function V(t,n){e.defined(C[t])||(C[t]=!0,console.warn(e.defaultValue(n,t)))}function L(n){var i=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).polylinePositions,r=n.shapePositions;this._positions=i,this._shape=r,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,o.CornerType.ROUNDED),this._vertexFormat=y.VertexFormat.clone(e.defaultValue(n.vertexFormat,y.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,c.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry",i=1+i.length*t.Cartesian3.packedLength,i+=1+r.length*t.Cartesian2.packedLength,this.packedLength=i+t.Ellipsoid.packedLength+y.VertexFormat.packedLength+2}V.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",V.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",V.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",V.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored",L.pack=function(n,i,r){var a;r=e.defaultValue(r,0);var o=n._positions,l=o.length;for(i[r++]=l,a=0;a<l;++a,r+=t.Cartesian3.packedLength)t.Cartesian3.pack(o[a],i,r);var s=n._shape;l=s.length;for(i[r++]=l,a=0;a<l;++a,r+=t.Cartesian2.packedLength)t.Cartesian2.pack(s[a],i,r);return t.Ellipsoid.pack(n._ellipsoid,i,r),r+=t.Ellipsoid.packedLength,y.VertexFormat.pack(n._vertexFormat,i,r),r+=y.VertexFormat.packedLength,i[r++]=n._cornerType,i[r]=n._granularity,i};var w=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),F=new y.VertexFormat,T={polylinePositions:void 0,shapePositions:void 0,ellipsoid:w,vertexFormat:F,cornerType:void 0,granularity:void 0};L.unpack=function(n,i,r){i=e.defaultValue(i,0);for(var a=n[i++],o=new Array(a),l=0;l<a;++l,i+=t.Cartesian3.packedLength)o[l]=t.Cartesian3.unpack(n,i);a=n[i++];var s=new Array(a);for(l=0;l<a;++l,i+=t.Cartesian2.packedLength)s[l]=t.Cartesian2.unpack(n,i);var p=t.Ellipsoid.unpack(n,i,w);i+=t.Ellipsoid.packedLength;var d=y.VertexFormat.unpack(n,i,F);i+=y.VertexFormat.packedLength;var u=n[i++],c=n[i];return e.defined(r)?(r._positions=o,r._shape=s,r._ellipsoid=t.Ellipsoid.clone(p,r._ellipsoid),r._vertexFormat=y.VertexFormat.clone(d,r._vertexFormat),r._cornerType=u,r._granularity=c,r):(T.polylinePositions=o,T.shapePositions=s,T.cornerType=u,T.granularity=c,new L(T))};var G=new i.BoundingRectangle;return L.createGeometry=function(e){var l=e._positions,c=n.arrayRemoveDuplicates(l,t.Cartesian3.equalsEpsilon),y=e._shape;y=o.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(y);if(!(c.length<2||y.length<3))return g.PolygonPipeline.computeWindingOrder2D(y)===g.WindingOrder.CLOCKWISE&&y.reverse(),l=i.BoundingRectangle.fromPoints(y,G),function(e,t,n,i){var o=new p.GeometryAttributes;i.position&&(o.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));var l,c,y,m,h,f=t.length,b=e.length/3,v=(b-2*f)/(2*f),E=g.PolygonPipeline.triangulate(t),P=(v-1)*f*6+2*E.length,_=u.IndexDatatype.createTypedArray(b,P),x=2*f,k=0;for(R=0;R<v-1;R++){for(l=0;l<f-1;l++)h=(c=2*l+R*f*2)+x,m=(y=c+1)+x,_[k++]=y,_[k++]=c,_[k++]=m,_[k++]=m,_[k++]=c,_[k++]=h;m=(y=1+(c=2*f-2+R*f*2))+x,h=c+x,_[k++]=y,_[k++]=c,_[k++]=m,_[k++]=m,_[k++]=c,_[k++]=h}if(i.st||i.tangent||i.bitangent){for(var C,L,w=new Float32Array(2*b),F=1/(v-1),T=1/n.height,G=n.height/2,A=0,R=0;R<v;R++){for(L=T*(t[0].y+G),w[A++]=C=R*F,w[A++]=L,l=1;l<f;l++)L=T*(t[l].y+G),w[A++]=C,w[A++]=L,w[A++]=C,w[A++]=L;L=T*(t[0].y+G),w[A++]=C,w[A++]=L}for(l=0;l<f;l++)L=T*(t[l].y+G),w[A++]=C=0,w[A++]=L;for(l=0;l<f;l++)L=T*(t[l].y+G),w[A++]=C=(v-1)*F,w[A++]=L;o.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(w)})}var D=b-2*f;for(R=0;R<E.length;R+=3){var I=E[R]+D,O=E[R+1]+D,S=E[R+2]+D;_[k++]=I,_[k++]=O,_[k++]=S,_[k++]=S+f,_[k++]=O+f,_[k++]=I+f}if(e=new s.Geometry({attributes:o,indices:_,boundingSphere:r.BoundingSphere.fromVertices(e),primitiveType:s.PrimitiveType.TRIANGLES}),i.normal&&(e=d.GeometryPipeline.computeNormal(e)),i.tangent||i.bitangent){try{e=d.GeometryPipeline.computeTangentAndBitangent(e)}catch(e){V("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(e.attributes.tangent=void 0),i.bitangent||(e.attributes.bitangent=void 0),i.st||(e.attributes.st=void 0)}return e}(o.PolylineVolumeGeometryLibrary.computePositions(c,y,l,e,!0),y,l,e._vertexFormat)},function(n,i){return(n=e.defined(i)?L.unpack(n,i):n)._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),L.createGeometry(n)}}));